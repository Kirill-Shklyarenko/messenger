Установка.
==========
1. Для того чтобы собрать микросервис:

* `docker-compose build`

* `docker-compose up -d`

2. Для того чтобы создать пользователя с правами администратора:
   `docker-compose exec api python manage.py createsuperuser`


Обоснование.
============

Почему DRF?
-----------
- API автоматически документируется с помощью удобного и понятного для
  пользователя вывода в формате HTML, предоставляя красивый интерфейс в
  виде формы для отправки данных и извлечения из них стандартными
  методами HTTP.
- Веб-приложение, и серверная часть API находятся в одной и той же базе
  кода, согласовываясь с принципом DRY.
- Поддержка ORM. В которой, я сделал unique together constraints на
  содержимое сообщения и получателей. Т.к. считаю что исключение
  возможности многократной отправки одного и того же сообщения одному
  получателю это работа БД, а не логики и валидации сериализаторов.
- Безопасность(CSRF, SQL-инъекции, XSS, etc.) Чтобы сделать наш RESTful
  API надежным и безопасным, мы можем реализовать авторизацию и
  аутентификацию, чтобы разрешить ограниченный доступ на основе учетных
  данных. А также Throttling, который используется для ограничения
  скорости запросов к API и их количества от одного пользователя, чтобы
  избежать любого рода DDoS-атак.
- Производительность.
- Архитектура.
- Масштабируемость.
- Встроенная Django Admin'ка.

Почему Celery?
--------------
- Интеграция с Django
- Запланированные задачи по времени
- Autorerty + rerty N-ое количество раз
- Workflow
- Очередь задач
- Развитая инфраструктура
- Выбор различных брокеров

Почему RabbitMQ?
----------------
- Всякий раз, когда мы полагаемся на внешние API, например, для отправки
  сообщений, мы больше не контролируем, сколько времени потребуется для
  выполнения операции до завершения. В некоторых случаях операция может
  никогда не выполниться, например, если серверы API недоступны либо не
  работают. Асинхронная реализация внешних API-интерфейсов абстрагирует
  наших пользователей от длительных задержек/ошибок, которые могут
  произойти. Cообщения не удаляются из очереди до тех пор, пока они не
  будут успешно выполнены. Это означает, что Celery workers будут
  продолжать пытаться использовать сообщение до тех пор, пока не будет
  достигнут успех, когда внешний API снова подключится к сети.
