Ваша задача: создать прототип микросервиса, обеспечивающий эмуляцию  отправки сообщений в популярные мессенджеры (Viber, Telegram, WhatsApp).
=============================================================================================================================================

Приложение должно обладать следующим функционалом:
--------------------------------------------------

- прием сообщений по API и отправка их в мессенджеры (с указанием
  идентификатора пользователя для каждого мессенджера);
- возможность отложенной отправки сообщений по дате/времени;
- в случае неудачной отправки сообщения, нужно повторить попытку N-ое
  количество раз, но это не должно влиять на доставляемость других
  сообщений;
- исключение возможности многократной отправки одного и того же
  сообщения (с одним и тем же содержимым) одному получателю;
- возможность отправки одного сообщения нескольким получателям на
  несколько мессенджеров в рамках одного запроса;
- после рестарта сервиса не должны пропасть "отложенные сообщения" или
  сообщения "в процессе отправки".
- написаны Unit-тесты по ключевому функционалу

- БОНУС: использование Docker
- Задание нужно прислать нам вместе с README, в котором должна быть инструкция по развертыванию/запуску и описание API-запросов.
- Использование любых инструментов — на вашей совести, однако выбор необходимо будет обосновать там же в README.


Обоснование.
============

Почему DRF?
-----------

- API автоматически документируется с помощью удобного и понятного для
  пользователя вывода в формате HTML, предоставляя красивый интерфейс в
  виде формы для отправки данных и извлечения из них стандартными
  методами HTTP.
- Веб-приложение, и серверная часть API находятся в одной и той же базе
  кода, согласовываясь с принципом DRY.
- Поддержка ORM. В которой, я сделал unique together constraints на
  содержимое сообщения и получателей. Т.к. считаю что исключение
  возможности многократной отправки одного и того же сообщения одному
  получателю это работа БД, а не логики и валидации сериализаторов.
- Безопасность(CSRF, SQL-инъекции, XSS, etc.) Чтобы сделать наш RESTful
  API надежным и безопасным, мы можем реализовать авторизацию и
  аутентификацию, чтобы разрешить ограниченный доступ на основе учетных
  данных, так же можно добавить ограничения скорости, чтобы избежать
  любого рода DDoS-атак. + Throttling, который используется для
  ограничения скорости запросов к API и их количества от одного
  пользователя.
- Производительность.
- Архитектура.
- Масштабируемость.
- Встроенная Django Admin'ка.


Почему Celery?
--------------

- Интеграция с Django
- Развитая инфраструктура
- Запланированные задачи по времени
- Выбор различных брокеров
- Очередь задач
- Workflow
- Autorerty + rerty N-ое количество раз


Почему RabbitMQ?
----------------

- Всякий раз, когда мы полагаемся на внешние API, например, для отправки
  сообщений, мы больше не контролируем, сколько времени потребуется для
  выполнения операции до завершения. В некоторых случаях операция может
  никогда не выполниться, например, если серверы API недоступны либо не
  работают. Асинхронная реализация внешних API-интерфейсов абстрагирует
  наших пользователей от длительных задержек/ошибок, которые могут
  произойти. Cообщения не удаляются из очереди до тех пор, пока они не
  будут успешно выполнены. Это означает, что Celery workers будут
  продолжать пытаться использовать сообщение до тех пор, пока не будет
  достигнут успех, когда внешний API снова подключится к сети.
